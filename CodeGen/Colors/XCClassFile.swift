//
//  XCClassFile.swift
//  ColorExtension
//
//  Created by DươngPQ on 12/02/2018.
//  Copyright © 2018 GMO-Z.com RunSystem. All rights reserved.
//

import Foundation

class XCClassFile {

    let prefix: String?
    let organization: String?
    let indentWidth: Int
    let tabWidth: Int
    let useTab: Bool
    let year: Int
    let projectPath: String
    let swiftlintEnable: Bool

    init?(project: String) {
        guard let allItems = try? FileManager.default.contentsOfDirectory(atPath: project) else {
            return nil
        }
        var path: String?
        for item in allItems where item.hasSuffix(".xcodeproj") {
            path = (project as NSString).appendingPathComponent(item + "/project.pbxproj")
            break
        }
        guard let pPath = path else { return nil }
        if let proj = NSDictionary(contentsOfFile: pPath),
            let root = proj["rootObject"] as? String, let objects = proj["objects"] as? NSDictionary,
            let rootObj = objects[root] as? NSDictionary, let attributes = rootObj["attributes"] as? NSDictionary,
            let main = rootObj["mainGroup"] as? String, let mainObj = objects[main] as? NSDictionary {
            projectPath = project
            prefix = attributes["CLASSPREFIX"] as? String
            organization = attributes["ORGANIZATIONNAME"] as? String
            indentWidth = Int(mainObj["indentWidth"] as? String ?? "4") ?? 4
            tabWidth = Int(mainObj["tabWidth"] as? String ?? "4") ?? 4
            useTab = (Int(mainObj["tabWidth"] as? String ?? "0") ?? 0) != 0
            var calender = Calendar(identifier: .gregorian)
            calender.locale = Locale.current
            calender.timeZone = NSTimeZone.local
            if let fileAttr = try? FileManager.default.attributesOfItem(atPath: pPath),
                let date = fileAttr[FileAttributeKey.modificationDate] as? Date {
                year = calender.component(.year, from: date)
            } else {
                year = calender.component(.year, from: Date())
            }

            var swiftlint = false
            if let targets = rootObj["targets"] as? [String] {
                for target in targets {
                    if let targetObj = objects[target] as? NSDictionary, let buildPhases = targetObj["buildPhases"] as? [String] {
                        for phase in buildPhases {
                            if let phaseObj = objects[phase] as? NSDictionary, let isa = phaseObj["isa"] as? String, isa == "PBXShellScriptBuildPhase",
                                let script = phaseObj["shellScript"] as? String, script.contains("swiftlint") {
                                swiftlint = true
                                break
                            }
                        }
                    }
                    if swiftlint { break }
                }
            }
            swiftlintEnable = swiftlint
        } else {
            return nil
        }
    }

    func write(content: String, target: String) -> Error? {
        var result = "//\n"
        result += "//  " + (target as NSString).lastPathComponent + "\n"
        result += "//\n"
        result += "//  Generated by CodeGen (by Some1)\n"
        if let organ = organization {
            result += "//  Copyright © \(year) \(organ). All rights reserved.\n"
        }
        result += "//\n"
        result += "//  THIS FILE IS AUTO-GENERATED. DO NOT EDIT!\n"
        result += content
        let pathTarget = target.hasPrefix("/") ? target : (projectPath as NSString).appendingPathComponent(target)
        do {
            try (result as NSString).write(toFile: pathTarget, atomically: true, encoding: String.Encoding.utf8.rawValue)
            return nil
        } catch let e {
            return e
        }
    }

}
